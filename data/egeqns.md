 * `(P₁(InIsle(f ∈ Terms,$kf))) == ((P₀(InIsle(f ∈ Terms,$kf))) * (0.55))`
 * `(P₁(InIsle({Terms ∈ Restrict(TypOpt)},$lx))) == (P₁(InIsle({Terms ∈ Restrict(TypOpt)},$lx)))`
 * `(P₁(Wrap(($mn :  A) ↦ ((f) ((f) ($mn)))) ∈ AtCoord(FuncsWithDomain,A :: HNil))) == ((P₁(InIsle((f) ((f) ($mn)) ∈ Terms,$mn))) * (0.1))`
 * `(P₁(InIsle(A ∈ Typs,$iw))) == ((P₀(InIsle(A ∈ Typs,$iw))) * (0.6))`
 * `(P₁(InIsle({(Funcs, Terms) ∈ Restrict(provingground.learning.GeneratorVariables$$Lambda$2144/734480558@29dcb4c8)},$lx))) == (P₁(InIsle({(Funcs, Terms) ∈ Restrict(provingground.learning.GeneratorVariables$$Lambda$2144/734480558@29dcb4c8)},$lx)))`
 * `(P₁(InIsle(a ∈ Terms,$jx))) == ((P₀(InIsle(a ∈ Terms,$jx))) * (0.55))`
 * `(P₁(InIsle((f) ((f) ($mn)) ∈ Terms,$mn))) == (1.0)`
 * `(P₁(InIsle((f) ((f) ($lx)) ∈ Terms,$lx))) == (1.0)`
 * `(P₁(InIsle((f) ((f) ($iw)) ∈ Terms,$iw))) == (1.0)`
 * `((P₁(f ∈ Terms)) + (P₁((a :  A) ↦ ((f) ((f) (a))) ∈ Terms))) == (P₁({Terms ∈ Restrict(FuncWithDom(A))}))`
 * `(P₁({Terms ∈ Restrict(TypFamilyOpt)})) == (P₁({Terms ∈ Restrict(TypFamilyOpt)}))`
 * `(P₁(InIsle(Wrap(f) ∈ Funcs,$lx))) == ((P₀(InIsle(Wrap(f) ∈ Funcs,$lx))) * (0.55))`
 * `(P₁(InIsle(a ∈ Terms,$kf))) == ((P₀(InIsle(a ∈ Terms,$kf))) * (0.55))`
 * `(P₁(InIsle(a ∈ Terms,$lx))) == ((P₀(InIsle(a ∈ Terms,$lx))) * (0.55))`
 * `(P₁(InIsle(A ∈ Terms,$jx))) == ((P₀(InIsle(A ∈ Terms,$jx))) * (0.55))`
 * `(P₁((f) ((f) (a)) ∈ Terms)) == ((((((P₁(Wrap((a :  A) ↦ ((f) ((f) (a)))) ∈ Funcs)) * (P₁(a ∈ Terms))) / (P₁({(Funcs, Terms) ∈ Restrict(provingground.learning.GeneratorEquations$$Lambda$2176/556232890@792d25c8)}))) * (0.1)) + (((P₁(a ∈ Terms)) * (P₁(Wrap((a :  A) ↦ ((f) ((f) (a)))) ∈ AtCoord(FuncsWithDomain,A :: HNil)))) * (0.1))) + ((((P₁(Wrap(f) ∈ Funcs)) * (P₁((f) (a) ∈ Terms))) / (P₁({(Funcs, Terms) ∈ Restrict(provingground.learning.GeneratorEquations$$Lambda$2176/556232890@7a0b2f0a)}))) * (0.1)))`
 * `(P₁(InIsle($mn ∈ Terms,$mn))) == ((P₀(InIsle($mn ∈ Terms,$mn))) * (0.55))`
 * `(P₁(InIsle(f ∈ Terms,$mn))) == ((P₀(InIsle(f ∈ Terms,$mn))) * (0.55))`
 * `(P₁(a ∈ Terms)) == ((P₀(a ∈ Terms)) * (0.55))`
 * `(P₁(InIsle($jx ∈ Terms,$jx))) == ((P₀(InIsle($jx ∈ Terms,$jx))) * (0.55))`
 * `(P₁(Wrap(f) ∈ AtCoord(FuncsWithDomain,A :: HNil))) == ((P₀(Wrap(f) ∈ AtCoord(FuncsWithDomain,A :: HNil))) * (0.55))`
 * `(P₁(InIsle({Terms ∈ Restrict(TypOpt)},$iw))) == (P₁(InIsle({Terms ∈ Restrict(TypOpt)},$iw)))`
 * `(P₁(InIsle({(Funcs, Terms) ∈ Restrict(provingground.learning.GeneratorVariables$$Lambda$2144/734480558@58e031a)},$mn))) == (P₁(InIsle({(Funcs, Terms) ∈ Restrict(provingground.learning.GeneratorVariables$$Lambda$2144/734480558@58e031a)},$mn)))`
 * `(P₁(InIsle(f ∈ Terms,$iw))) == ((P₀(InIsle(f ∈ Terms,$iw))) * (0.55))`
 * `(P₁(InIsle({Terms ∈ Restrict(TypFamilyOpt)},$mn))) == (P₁(InIsle({Terms ∈ Restrict(TypFamilyOpt)},$mn)))`
 * `((((((P₁((f) (a) ∈ Terms)) + (P₁(f ∈ Terms))) + (P₁((a :  A) ↦ ((f) ((f) (a))) ∈ Terms))) + (P₁(a ∈ Terms))) + (P₁((f) ((f) (a)) ∈ Terms))) + (P₁(A ∈ Terms))) == (1.0)`
 * `(P₁(InIsle($iw ∈ Terms,$iw))) == ((P₀(InIsle($iw ∈ Terms,$iw))) * (0.55))`
 * `(P₁(InIsle(Wrap(f) ∈ Funcs,$kf))) == ((P₀(InIsle(Wrap(f) ∈ Funcs,$kf))) * (0.55))`
 * `(P₁(InIsle(A ∈ Typs,$lx))) == ((P₀(InIsle(A ∈ Typs,$lx))) * (0.6))`
 * `(P₁(InIsle(Wrap(f) ∈ Funcs,$mn))) == ((P₀(InIsle(Wrap(f) ∈ Funcs,$mn))) * (0.55))`
 * `((P₁(f ∈ Terms)) + (P₁((a :  A) ↦ ((f) ((f) (a))) ∈ Terms))) == (P₁({Terms ∈ Restrict(FuncOpt)}))`
 * `(P₁(A ∈ Terms)) == ((P₀(A ∈ Terms)) * (0.55))`
 * `(P₁(InIsle({Terms ∈ Restrict(FuncOpt)},$jx))) == (P₁(InIsle({Terms ∈ Restrict(FuncOpt)},$jx)))`
 * `(P₁(InIsle({(Funcs, Terms) ∈ Restrict(provingground.learning.GeneratorVariables$$Lambda$2144/734480558@6a576173)},$kf))) == (P₁(InIsle({(Funcs, Terms) ∈ Restrict(provingground.learning.GeneratorVariables$$Lambda$2144/734480558@6a576173)},$kf)))`
 * `(P₁(InIsle(A ∈ Typs,$jx))) == ((P₀(InIsle(A ∈ Typs,$jx))) * (0.6))`
 * `(P₁(InIsle(f ∈ Terms,$jx))) == ((P₀(InIsle(f ∈ Terms,$jx))) * (0.55))`
 * `(P₁(InIsle(a ∈ Terms,$mn))) == ((P₀(InIsle(a ∈ Terms,$mn))) * (0.55))`
 * `(P₁(InIsle({Terms ∈ Restrict(TypOpt)},$kf))) == (P₁(InIsle({Terms ∈ Restrict(TypOpt)},$kf)))`
 * `(((((((P₁(Wrap((a :  A) ↦ ((f) ((f) (a)))) ∈ Funcs)) * (P₁((f) ((f) (a)) ∈ Terms))) + ((P₁(Wrap((a :  A) ↦ ((f) ((f) (a)))) ∈ Funcs)) * (P₁(a ∈ Terms)))) + ((P₁(Wrap(f) ∈ Funcs)) * (P₁(a ∈ Terms)))) + ((P₁(Wrap(f) ∈ Funcs)) * (P₁((f) (a) ∈ Terms)))) + ((P₁(Wrap((a :  A) ↦ ((f) ((f) (a)))) ∈ Funcs)) * (P₁((f) (a) ∈ Terms)))) + ((P₁(Wrap(f) ∈ Funcs)) * (P₁((f) ((f) (a)) ∈ Terms)))) == (P₁({(Funcs, Terms) ∈ Restrict(provingground.learning.GeneratorVariables$$Lambda$2144/734480558@30fc8393)}))`
 * `((P₁(Wrap((a :  A) ↦ ((f) ((f) (a)))) ∈ AtCoord(FuncsWithDomain,A :: HNil))) + (P₁(Wrap(f) ∈ AtCoord(FuncsWithDomain,A :: HNil)))) == (1.0)`
 * `(P₁(A ∈ Terms)) == (P₁({Terms ∈ Restrict(TypOpt)}))`
 * `(P₁((f) ((f) (a)) ∈ AtCoord(TermsWithTyp,A :: HNil))) == (((P₁((f) ((f) (a)) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))) * (0.1))`
 * `(P₁(InIsle(A ∈ Typs,$kf))) == ((P₀(InIsle(A ∈ Typs,$kf))) * (0.6))`
 * `(((P₁((f) (a) ∈ Terms)) + (P₁(a ∈ Terms))) + (P₁((f) ((f) (a)) ∈ Terms))) == (P₁({Terms ∈ Filter(WithTyp(typ))}))`
 * `(P₁((f) (a) ∈ Terms)) == (((((P₁(Wrap(f) ∈ Funcs)) * (P₁(a ∈ Terms))) / (P₁({(Funcs, Terms) ∈ Restrict(provingground.learning.GeneratorEquations$$Lambda$2176/556232890@70006aaa)}))) * (0.1)) + (((P₁(Wrap(f) ∈ Funcs)) * (P₁(a ∈ AtCoord(TermsWithTyp,A :: HNil)))) * (0.1)))`
 * `(P₁(($im :  A) ↦ ((f) ((f) ($im))) ∈ Terms)) == (((P₁(InIsle((f) ((f) ($im)) ∈ Terms,$im))) * (P₁(A ∈ Typs))) * (0.1))`
 * `(P₁(InIsle({Terms ∈ Restrict(FuncOpt)},$iw))) == (P₁(InIsle({Terms ∈ Restrict(FuncOpt)},$iw)))`
 * `(P₁(InIsle({Terms ∈ Restrict(TypOpt)},$mn))) == (P₁(InIsle({Terms ∈ Restrict(TypOpt)},$mn)))`
 * `(P₁(InIsle({Terms ∈ Restrict(FuncOpt)},$lx))) == (P₁(InIsle({Terms ∈ Restrict(FuncOpt)},$lx)))`
 * `(P₁(InIsle(a ∈ Terms,$iw))) == ((P₀(InIsle(a ∈ Terms,$iw))) * (0.55))`
 * `(P₁((f) (a) ∈ AtCoord(TermsWithTyp,A :: HNil))) == (((P₁((f) (a) ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))) * (0.1))`
 * `(P₁(InIsle(A ∈ Typs,$mn))) == ((P₀(InIsle(A ∈ Typs,$mn))) * (0.6))`
 * `(P₁(InIsle({Terms ∈ Restrict(FuncOpt)},$mn))) == (P₁(InIsle({Terms ∈ Restrict(FuncOpt)},$mn)))`
 * `(P₁(f ∈ Terms)) == ((P₀(f ∈ Terms)) * (0.55))`
 * `(P₁(Wrap(f) ∈ Funcs)) == ((P₀(Wrap(f) ∈ Funcs)) * (0.55))`
 * `(P₁(InIsle(A ∈ Terms,$iw))) == ((P₀(InIsle(A ∈ Terms,$iw))) * (0.55))`
 * `((P₁(Wrap(f) ∈ Funcs)) + (P₁(Wrap((a :  A) ↦ ((f) ((f) (a)))) ∈ Funcs))) == (1.0)`
 * `(P₁(InIsle({(Funcs, Terms) ∈ Restrict(provingground.learning.GeneratorVariables$$Lambda$2144/734480558@509e5cea)},$iw))) == (P₁(InIsle({(Funcs, Terms) ∈ Restrict(provingground.learning.GeneratorVariables$$Lambda$2144/734480558@509e5cea)},$iw)))`
 * `(P₁(InIsle(f ∈ Terms,$lx))) == ((P₀(InIsle(f ∈ Terms,$lx))) * (0.55))`
 * `(P₁(A ∈ Typs)) == ((((P₁(A ∈ Terms)) / (P₁({Terms ∈ Restrict(TypOpt)}))) * (0.1)) + ((P₀(A ∈ Typs)) * (0.6)))`
 * `(P₁(InIsle({Terms ∈ Restrict(TypFamilyOpt)},$iw))) == (P₁(InIsle({Terms ∈ Restrict(TypFamilyOpt)},$iw)))`
 * `(P₁(InIsle({Terms ∈ Restrict(FuncOpt)},$kf))) == (P₁(InIsle({Terms ∈ Restrict(FuncOpt)},$kf)))`
 * `(P₁(InIsle({Terms ∈ Restrict(TypFamilyOpt)},$jx))) == (P₁(InIsle({Terms ∈ Restrict(TypFamilyOpt)},$jx)))`
 * `(P₁(InIsle(A ∈ Terms,$mn))) == ((P₀(InIsle(A ∈ Terms,$mn))) * (0.55))`
 * `(P₁(InIsle($lx ∈ Terms,$lx))) == ((P₀(InIsle($lx ∈ Terms,$lx))) * (0.55))`
 * `(P₁(a ∈ AtCoord(TermsWithTyp,A :: HNil))) == (((P₀(a ∈ AtCoord(TermsWithTyp,A :: HNil))) * (0.55)) + (((P₁(a ∈ Terms)) / (P₁({Terms ∈ Filter(WithTyp(typ))}))) * (0.1)))`
 * `(((P₁((f) (a) ∈ AtCoord(TermsWithTyp,A :: HNil))) + (P₁(a ∈ AtCoord(TermsWithTyp,A :: HNil)))) + (P₁((f) ((f) (a)) ∈ AtCoord(TermsWithTyp,A :: HNil)))) == (1.0)`
 * `(P₁(InIsle((f) ((f) ($kf)) ∈ Terms,$kf))) == (1.0)`
 * `(P₁(A ∈ Typs)) == (1.0)`
 * `(P₁(InIsle({(Funcs, Terms) ∈ Restrict(provingground.learning.GeneratorVariables$$Lambda$2144/734480558@48b30a6a)},$jx))) == (P₁(InIsle({(Funcs, Terms) ∈ Restrict(provingground.learning.GeneratorVariables$$Lambda$2144/734480558@48b30a6a)},$jx)))`
 * `(P₁(InIsle(Wrap(f) ∈ Funcs,$jx))) == ((P₀(InIsle(Wrap(f) ∈ Funcs,$jx))) * (0.55))`
 * `(P₁(InIsle(Wrap(f) ∈ Funcs,$iw))) == ((P₀(InIsle(Wrap(f) ∈ Funcs,$iw))) * (0.55))`
 * `(P₁(InIsle({Terms ∈ Restrict(TypFamilyOpt)},$lx))) == (P₁(InIsle({Terms ∈ Restrict(TypFamilyOpt)},$lx)))`
 * `(P₁(InIsle({Terms ∈ Restrict(TypFamilyOpt)},$kf))) == (P₁(InIsle({Terms ∈ Restrict(TypFamilyOpt)},$kf)))`
 * `(P₁(InIsle(A ∈ Terms,$kf))) == ((P₀(InIsle(A ∈ Terms,$kf))) * (0.55))`
 * `(P₁(InIsle((f) ((f) ($jx)) ∈ Terms,$jx))) == (1.0)`
 * `(P₁(InIsle($kf ∈ Terms,$kf))) == ((P₀(InIsle($kf ∈ Terms,$kf))) * (0.55))`
 * `(P₁(InIsle(A ∈ Terms,$lx))) == ((P₀(InIsle(A ∈ Terms,$lx))) * (0.55))`
 * `(P₁(InIsle({Terms ∈ Restrict(TypOpt)},$jx))) == (P₁(InIsle({Terms ∈ Restrict(TypOpt)},$jx)))`
