
<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>ProvingGround</title>
    <link rel="icon" href="../IIScLogo.jpg">

    <!-- Bootstrap -->
    <link href="../css/bootstrap.min.css" rel="stylesheet">
   |<link href="../css/katex.min.css" rel="stylesheet">
   |<link href="../css/main.css" rel="stylesheet">


    <link rel="stylesheet" href="../css/zenburn.css">
    <script src="../js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

   |<script src="../js/ace.js"></script>
   |<script src="../js/katex.min.js"></script>

        <!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
jax: ["input/TeX", "output/HTML-CSS"],
tex2jax: {
  inlineMath: [ ['$', '$'] ],
  displayMath: [ ['$$', '$$']],
  processEscapes: true,
  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
},
messageStyle: "none",
"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
});
</script>
<script type="text/javascript" async
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
       </script>

  </head>


<body>
<nav class="navbar navbar-default">
      <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <span class="navbar-brand">ProvingGround</span>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
          <ul class="nav navbar-nav">
            <li><a href="../index.html#">Home</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
                Tutorials (notes)<span class="caret"></span></a>
              <ul class="dropdown-menu">
                <li class="dropdown-header"><strong>Tutorials (notes)</strong></li>
                <li><a href="../tuts/hott.html">HoTT</a></li><li><a href="../tuts/left-and-right-identities.html">Left and Right Identities</a></li><li><a href="../tuts/internal-repetition-for-length-functions.html">Internal repetition for length functions</a></li><li><a href="../tuts/inductive-types-(old-style).html">Inductive Types (old style)</a></li><li><a href="../tuts/inductive-types.html">Inductive Types</a></li><li><a href="../tuts/scalarep.html">ScalaRep</a></li><li><a href="../tuts/symbolic-algebra.html">Symbolic algebra</a></li>
            </ul>
          </li>
      </ul>
          <ul class="nav navbar-nav navbar-right">
            <li> <a href="../scaladoc/provingground/index.html" target="_blank">ScalaDocs</a></li>
            <li> <a href="https://github.com/siddhartha-gadgil/ProvingGround" target="_blank">
            <img src="../GitHub-Mark-Light-32px.png" alt="Github"></img> </a> </li>



          </ul>
        </div><!-- /.navbar-collapse -->
      </div><!-- /.container-fluid -->
    </nav>
<div class="container">
<h1 class="text-center">Internal repetition for length functions</h1>

<div class="text-justify">
<p>We formalize (in code) the combinatorial group theory part of the <em>spltting lemma</em> of the paper <a href="https://arxiv.org/abs/1801.03908">Homogenous length functions on Groups</a>. This is based on an implementation (in <em>scala</em>) of a large part of Homotopy type theory equipped with symbolic algebra in this project.</p>
<h2>The statement</h2>
<p>Assume we are given the following:</p>
<ul>
<li>A group $G$.</li>
<li>A (length) function $l: G \to \mathbb{Q}$ such that
<ul>
<li>For $g, h \in G$, $l(gh) \leq l(g) + l(h)$,</li>
<li>For $g, h\in G$, $l(ghg^{-1}) = l(g$).</li>
</ul>
</li>
<li>Elements $x, y, z, w \in G$ such that
<ul>
<li>$x \sim yw$ (here $\sim$ means conjugate in $G$),</li>
<li>$x \sim zw^{-1}$.</li>
</ul>
</li>
</ul>
<p>Then we have the following:</p>
<p><strong>Theorem:</strong> There exists a constant $A\in\mathbb{Q}$ so that for $n \in \mathbb{N}$,</p>
<p>$$l(x^{2n}) \leq n(l(y) + l(z)) +A.$$</p>
<p>In the above paper, homogeneity is used to deduce a bound for $l(x)$, and on taking the limit we get $l(x) \leq \frac{l(y) + l(z)}{2}$.</p>
<h2>Preliminaries</h2>
<p>We start with some imports. This is a bit ugly due to avoiding variable name collisions.</p>
<pre><code class="language-scala">scala&gt;    

scala&gt; import provingground._, HoTT._ 

import provingground._, HoTT._

scala&gt;  

scala&gt; import functionfinder._, andrewscurtis.FreeGroups._ 

import functionfinder._, andrewscurtis.FreeGroups._

scala&gt; import spire.implicits._ 

import spire.implicits._

scala&gt; 
import NatRing.{ x=&gt;_,  Literal =&gt; nat, _}, QField.{w =&gt; _, x =&gt;_, y=&gt;_, z=&gt;_, Literal =&gt; rat, _}, FreeGroup.{Literal =&gt; elem, _} 

import NatRing.{ x=&gt;_,  Literal =&gt; nat, _}, QField.{w =&gt; _, x =&gt;_, y=&gt;_, z=&gt;_, Literal =&gt; rat, _}, FreeGroup.{Literal =&gt; elem, _}

scala&gt; import Theorems.{PowerDistributive, ConjPower} 

import Theorems.{PowerDistributive, ConjPower}
</code></pre>
<h2>The Setup</h2>
<p>We introduce terms for the length function $l$, as well as <em>witnesses</em> for the assumptions on $l$.</p>
<pre><code class="language-scala">scala&gt; val l = &quot;l&quot; :: FreeGroup -&gt;: QTyp 

l: Func[RepTerm[Word], RepTerm[spire.math.Rational]] with Subs[Func[RepTerm[Word], RepTerm[spire.math.Rational]]] = l

scala&gt;  

scala&gt; val g = &quot;g&quot; :: FreeGroup 

g: RepTerm[Word] with Subs[RepTerm[Word]] = g

scala&gt; val h = &quot;h&quot; :: FreeGroup 

h: RepTerm[Word] with Subs[RepTerm[Word]] = h

scala&gt; val n = &quot;n&quot; :: NatTyp 

n: RepTerm[spire.math.SafeLong] with Subs[RepTerm[spire.math.SafeLong]] = n

scala&gt;  

scala&gt; val triang =
         &quot;triangle-inequality&quot; :: (
           g ~&gt;: (h ~&gt;: (
             (leq(l(g |+| h))(l(g) + l(h)))
           ))
         ) 

triang: FuncLike[RepTerm[Word] with Subs[RepTerm[Word]], FuncLike[RepTerm[Word] with Subs[RepTerm[Word]], PosWit]] with Subs[FuncLike[RepTerm[Word] with Subs[RepTerm[Word]], FuncLike[RepTerm[Word] with Subs[RepTerm[Word]], PosWit]]] = triangle-inequality

scala&gt;  

scala&gt; val conjInv =
         &quot;conjugacy-invariance&quot; :: (
           g ~&gt;: (
             h ~&gt;: (
               (l(h) =:= (l(g |+| h |+| g.inverse)))
             )
           )
         ) 

conjInv: FuncLike[RepTerm[Word] with Subs[RepTerm[Word]], FuncLike[RepTerm[Word] with Subs[RepTerm[Word]], Equality[RepTerm[spire.math.Rational]]]] with Subs[FuncLike[RepTerm[Word] with Subs[RepTerm[Word]], FuncLike[RepTerm[Word] with Subs[RepTerm[Word]], Equality[RepTerm[spire.math.Rational]]]]] = conjugacy-invariance

scala&gt;
</code></pre>
<p>Next, we introduce variables for $x, y, z, s, t \in G$, where $s, t \in G$ are the elements so that the conjugacies $x \sim wy$ and $x \sim zw^{-1}$ are given by the equations  $x = swys^{-1}$ and $x = tzw^{-1}t^{-1}$.</p>
<pre><code class="language-scala">scala&gt; val w = &quot;w&quot; :: FreeGroup 

w: RepTerm[Word] with Subs[RepTerm[Word]] = w

scala&gt; val y = &quot;y&quot; :: FreeGroup 

y: RepTerm[Word] with Subs[RepTerm[Word]] = y

scala&gt; val z = &quot;z&quot; :: FreeGroup 

z: RepTerm[Word] with Subs[RepTerm[Word]] = z

scala&gt; val s = &quot;s&quot; :: FreeGroup 

s: RepTerm[Word] with Subs[RepTerm[Word]] = s

scala&gt; val t = &quot;t&quot; :: FreeGroup 

t: RepTerm[Word] with Subs[RepTerm[Word]] = t
</code></pre>
<p>So far these are all independent. We shall introduce terms as witnesses for the above equations later, as we first prove a lemma not involving $x$.</p>
<h2>Statement of lemma</h2>
<p>The main internal repetition trick is captured the bound</p>
<p>$$l((wy)^ns^{-1}t(zw^{-1})^n)\leq n(l(y) + l(z)) + l(s^{-1}) + l(t).$$</p>
<p>We define $c(n) = (wy)^ns^{-1}t(zw^{-1})^n$ and $f(n) = n(l(y) + l(z)) + l(s^{-1}) + l(t)$, so the inequality is $l(c(n))\leq(f(n))$. We encode this  below as the <em>main lemma</em>.</p>
<pre><code class="language-scala">scala&gt; val wy = w |+| y 

wy: LocalTerm = ((mul) (w)) (y)

scala&gt; val zwbar = z |+| w.inverse 

zwbar: LocalTerm = ((mul) (z)) ((inv) (w))

scala&gt; val wyn = FreeGroup.power(wy)(n) 

wyn: RepTerm[Word] = (&lt;function1&gt;) (n)

scala&gt; val zwbarn = FreeGroup.power(zwbar)(n) 

zwbarn: RepTerm[Word] = (&lt;function1&gt;) (n)

scala&gt;  

scala&gt; val c = n :-&gt; (wyn |+| s.inverse |+| t |+| zwbarn) // this is the function we have to bound. 

c: Func[RepTerm[spire.math.SafeLong] with Subs[RepTerm[spire.math.SafeLong]], LocalTerm] = (n :  Nat.Typ) ↦ (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) ((&lt;function1&gt;) (n)))))

scala&gt;  

scala&gt; val r = incl(QField) 

r: Rec[LocalTerm] = &lt;function1&gt;

scala&gt;  

scala&gt; val f = n :-&gt; (l(s.inverse) + l(t) + ((l(y) + l(z)) * r(n) ) ) 

f: Func[RepTerm[spire.math.SafeLong] with Subs[RepTerm[spire.math.SafeLong]], LocalTerm] = (n :  Nat.Typ) ↦ (((l) (t) + (l) ((inv) (s)) + ((&lt;function1&gt;) (n) * (l) (z)) + ((&lt;function1&gt;) (n) * (l) (y))))

scala&gt;  

scala&gt; val lemma = n :-&gt; (leq (l(c(n)) )(f(n) ) ) 

lemma: Func[RepTerm[spire.math.SafeLong] with Subs[RepTerm[spire.math.SafeLong]], Pos] = (n :  Nat.Typ) ↦ (Pos((((l) (y) * (&lt;function1&gt;) (n)) + (l) (t) + ((l) (z) * (&lt;function1&gt;) (n)) + (l) ((inv) (s)) + ((prod) (-1)) ((l) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) ((&lt;function1&gt;) (n)))))))))
</code></pre>
<h2>Proving the lemma</h2>
<p>Let $d(n) = (wy)(wy)^ns^{-1}t(zw^{-1})^n(zw)$. Note that by definition $g^{n+1} = g^n g$, so we need to prove $d(n) = c(n+1)$.
We use $g^ng^m = g^{n+m}$ (proved in our code) to prove this. The proof is given by the term <code>dIsc</code>.</p>
<pre><code class="language-scala">scala&gt; val d = n :-&gt; (wy |+| wyn |+| s.inverse |+| t |+| zwbarn  |+| zwbar) 

d: Func[RepTerm[spire.math.SafeLong] with Subs[RepTerm[spire.math.SafeLong]], LocalTerm] = (n :  Nat.Typ) ↦ (((mul) (w)) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))

scala&gt; val dIsc = FreeGroup.rm(s.inverse |+| t |+| zwbarn |+| zwbar) *: (PowerDistributive.pf(wy)(nat(1))(n)) 

dIsc: Equality[LocalTerm] = (ind{($dpez :  FreeGroup) ↦ (($dpfa :  FreeGroup) ↦ ($dpez = $dpfa))(((mul) (w)) (((mul) (y)) ((&lt;function1&gt;) (n))))(((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (y)))}{($adqc :  FreeGroup) ↦ (($adqd :  FreeGroup) ↦ ((_ : ($adqc = $adqd) :  $adqc = $adqd) ↦ (((mul) ($adqc)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))) = ((mul) ($adqd)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))}(($adqc :  FreeGroup) ↦ (Refl(FreeGroup,((mul) ($adqc)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))) ((&lt;function1&gt;) (n) : (((mul) (w)) (((mul) (y)) ((&lt;function1&gt;) (n))) = ((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (y)))) : (((mul) (w)) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))) = ((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (((mul) (y)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))

scala&gt; assert(dIsc.typ == (d(n) =:= c(succ(n))))
</code></pre>
<p>Next, let $b(n) = y(wy)^ns^{-1}t(zw^{-1})^nz$ be the conjugacy-reduced form of $d(n)$. Using $d(n) = c(n+1)$ and conjugacy invariance, we show that $l(c(n+1)) = l(b(n))$. The term <code>bIsc</code> is the proof of <code>l(c(n+1)) = l(b(n))</code>.</p>
<pre><code class="language-scala">scala&gt; val b = n :-&gt; (y |+| wyn |+| s.inverse |+| t |+| zwbarn  |+| z) 

b: Func[RepTerm[spire.math.SafeLong] with Subs[RepTerm[spire.math.SafeLong]], LocalTerm] = (n :  Nat.Typ) ↦ (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (z))))))

scala&gt; val lbIsld = conjInv(w)(y |+| c(n) |+| z) 

lbIsld: Equality[RepTerm[spire.math.Rational]] = ((conjugacy-invariance) (w)) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (z)))))) : ((l) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (z)))))) = (l) (((mul) (w)) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w))))))))))

scala&gt; val bIsc = lbIsld &amp;&amp; (l *: dIsc) 

bIsc: Equality[RepTerm[spire.math.Rational] with Subs[RepTerm[spire.math.Rational]]] = ((ind{($stpx :  Q.Typ) ↦ (($stpy :  Q.Typ) ↦ ($stpx = $stpy))((l) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (z)))))))((l) (((mul) (w)) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w))))))))))}{($hiur :  Q.Typ) ↦ (($hius :  Q.Typ) ↦ ((_ : ($hiur = $hius) :  $hiur = $hius) ↦ (($hius = (l) (((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (((mul) (y)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))) → ($hiur = (l) (((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (((mul) (y)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))))))}(($hiur :  Q.Typ) ↦ (($hjjh : ($hiur = (l) (((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (((mul) (y)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))) :  $hiur = (l) (((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (((mul) (y)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))) ↦ ($hjjh : ($hiur = (l) (((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (((mul) (y)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))))))) (((conjugacy-invariance) (w)) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (z)))))) : ((l) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (z)))))) = (l) (((mul) (w)) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))))) ((ind{($stqa :  FreeGroup) ↦ (($stqb :  FreeGroup) ↦ ($stqa = $stqb))(((mul) (w)) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))(((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (((mul) (y)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))}{($dtmg :  FreeGroup) ↦ (($dtmh :  FreeGroup) ↦ ((_ : ($dtmg = $dtmh) :  $dtmg = $dtmh) ↦ ((l) ($dtmg) = (l) ($dtmh))))}(($dtmg :  FreeGroup) ↦ (Refl(Q.Typ,(l) ($dtmg))))) ((ind{($dpez :  FreeGroup) ↦ (($dpfa :  FreeGroup) ↦ ($dpez = $dpfa))(((mul) (w)) (((mul) (y)) ((&lt;function1&gt;) (n))))(((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (y)))}{($adqc :  FreeGroup) ↦ (($adqd :  FreeGroup) ↦ ((_ : ($adqc = $adqd) :  $adqc = $adqd) ↦ (((mul) ($adqc)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))) = ((mul) ($adqd)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))}(($adqc :  FreeGroup) ↦ (Refl(FreeGroup,((mul) ($adqc)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))) ((&lt;function1&gt;) (n) : (((mul) (w)) (((mul) (y)) ((&lt;function1&gt;) (n))) = ((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (y)))) : (((mul) (w)) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))) = ((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (((mul) (y)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))) : ((l) (((mul) (w)) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w))))))))) = (l) (((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (((mul) (y)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w))))))))))) : ((l) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (z)))))) = (l) (((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (((mul) (y)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w))))))))))

scala&gt; assert(bIsc.typ == (l(b(n)) =:= l(c(succ(n))) ))
</code></pre>
<p>With these preliminaries, we can prove the lemma by induction. First note the base case.</p>
<pre><code class="language-scala">scala&gt; val baseCase = triang(inv(s))(t) !: (lemma(0)) 

baseCase: PosWit = ((triangle-inequality) ((inv) (s))) (t) : (Pos((((prod) (-1)) ((l) (((mul) ((inv) (s))) (t))) + (l) ((inv) (s)) + (l) (t))))
</code></pre>
<p>The induction step takes more work.
We first assume the induction hypothesis.</p>
<pre><code class="language-scala">scala&gt; val hyp = &quot;hyp&quot; :: lemma(n) 

hyp: PosWit with Subs[PosWit] = hyp : (Pos(((l) (t) + ((&lt;function1&gt;) (n) * (l) (z)) + ((prod) (-1)) ((l) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) ((&lt;function1&gt;) (n)))))) + (l) ((inv) (s)) + ((l) (y) * (&lt;function1&gt;) (n)))))
</code></pre>
<p>Next, we bound $l(b(n))$ (which we know is $l(c(n+ 1)))$ in terms of $l(c(n))$.</p>
<pre><code class="language-scala">scala&gt; val lbnBoundedlcnlylz = triang(y)(c(n)) + triang(y |+| c(n))(z) 

lbnBoundedlcnlylz: PosWitSum = PosWitSum(((triangle-inequality) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) ((&lt;function1&gt;) (n))))) : (Pos((((prod) (-1)) ((l) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) ((&lt;function1&gt;) (n))))))) + (l) (y) + (l) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) ((&lt;function1&gt;) (n)))))))),((triangle-inequality) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) ((&lt;function1&gt;) (n))))))) (z) : (Pos((((prod) (-1)) ((l) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (z))))))) + (l) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) ((&lt;function1&gt;) (n)))))) + (l) (z)))))

scala&gt; assert(lbnBoundedlcnlylz.typ == (leq(l(b(n)))(l(c(n)) + l(y) + l(z))))
</code></pre>
<p>Now, using the induction hypothesis, we get a bound on $l(b(n))$.</p>
<pre><code class="language-scala">scala&gt; val lbnBounded = lbnBoundedlcnlylz + hyp 

lbnBounded: PosWitSum = PosWitSum(PosWitSum(((triangle-inequality) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) ((&lt;function1&gt;) (n))))) : (Pos((((prod) (-1)) ((l) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) ((&lt;function1&gt;) (n))))))) + (l) (y) + (l) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) ((&lt;function1&gt;) (n)))))))),((triangle-inequality) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) ((&lt;function1&gt;) (n))))))) (z) : (Pos((((prod) (-1)) ((l) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (z))))))) + (l) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) ((&lt;function1&gt;) (n)))))) + (l) (z))))),hyp : (Pos(((l) (t) + ((&lt;function1&gt;) (n) * (l) (z)) + ((prod) (-1)) ((l) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) ((&lt;function1&gt;) (n)))))) + (l) ((inv) (s)) + ((l) (y) * (&lt;function1&gt;) (n))))))

scala&gt; assert(lbnBounded.typ == leq(l(b(n)) )(f(succ(n))) )
</code></pre>
<p>Next, we put together $l(c(n+1)) = l(b(n))$ and the bound on $l(b(n))$ to get the required bound on $l(c(n+1))$.</p>
<pre><code class="language-scala">scala&gt; val bnd = &quot;bound&quot; :: QField.LocalTyp 

bnd: RepTerm[spire.math.Rational] with Subs[RepTerm[spire.math.Rational]] = bound

scala&gt; val cbnd = bIsc.lift(bnd :-&gt; (leq(bnd)(f(succ(n)) ) )) 

cbnd: Func[PosWit, PosWit] = (ind{($blsxk :  Q.Typ) ↦ (($blsxl :  Q.Typ) ↦ ($blsxk = $blsxl))((l) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (z)))))))((l) (((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (((mul) (y)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w))))))))))}{($taxo :  Q.Typ) ↦ (($taxp :  Q.Typ) ↦ ((_ : ($taxo = $taxp) :  $taxo = $taxp) ↦ ((Pos(((l) (t) + ((&lt;function1&gt;) (n) * (l) (z)) + (l) (y) + (l) ((inv) (s)) + ((prod) (-1)) ($taxo) + (l) (z) + ((l) (y) * (&lt;function1&gt;) (n))))) → (Pos((((prod) (-1)) ($taxp) + (l) (t) + ((&lt;function1&gt;) (n) * (l) (z)) + (l) (y) + (l) ((inv) (s)) + (l) (z) + ((l) (y) * (&lt;function1&gt;) (n))))))))}(($taxo :  Q.Typ) ↦ (($adhgo : (Pos((((prod) (-1)) ($taxo) + (l) (t) + ((l) (z) * (&lt;function1&gt;) (n)) + (l) (y) + (l) ((inv) (s)) + (l) (z) + ((l) (y) * (&lt;function1&gt;) (n))))) :  Pos((((prod) (-1)) ($taxo) + (l) (t) + ((l) (z) * (&lt;function1&gt;) (n)) + (l) (y) + (l) ((inv) (s)) + (l) (z) + ((l) (y) * (&lt;function1&gt;) (n))))) ↦ ($adhgo : (Pos((((prod) (-1)) ($taxo) + (l) (t) + ((&lt;function1&gt;) (n) * (l) (z)) + (l) (y) + (l) ((inv) (s)) + (l) (z) + ((l) (y) * (&lt;function1&gt;) (n))))))))) (((ind{($stpx :  Q.Typ) ↦ (($stpy :  Q.Typ) ↦ ($stpx = $stpy))((l) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (z)))))))((l) (((mul) (w)) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w))))))))))}{($hiur :  Q.Typ) ↦ (($hius :  Q.Typ) ↦ ((_ : ($hiur = $hius) :  $hiur = $hius) ↦ (($hius = (l) (((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (((mul) (y)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))) → ($hiur = (l) (((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (((mul) (y)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))))))}(($hiur :  Q.Typ) ↦ (($hjjh : ($hiur = (l) (((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (((mul) (y)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))) :  $hiur = (l) (((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (((mul) (y)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))) ↦ ($hjjh : ($hiur = (l) (((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (((mul) (y)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))))))) (((conjugacy-invariance) (w)) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (z)))))) : ((l) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (z)))))) = (l) (((mul) (w)) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))))) ((ind{($stqa :  FreeGroup) ↦ (($stqb :  FreeGroup) ↦ ($stqa = $stqb))(((mul) (w)) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))(((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (((mul) (y)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))}{($dtmg :  FreeGroup) ↦ (($dtmh :  FreeGroup) ↦ ((_ : ($dtmg = $dtmh) :  $dtmg = $dtmh) ↦ ((l) ($dtmg) = (l) ($dtmh))))}(($dtmg :  FreeGroup) ↦ (Refl(Q.Typ,(l) ($dtmg))))) ((ind{($dpez :  FreeGroup) ↦ (($dpfa :  FreeGroup) ↦ ($dpez = $dpfa))(((mul) (w)) (((mul) (y)) ((&lt;function1&gt;) (n))))(((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (y)))}{($adqc :  FreeGroup) ↦ (($adqd :  FreeGroup) ↦ ((_ : ($adqc = $adqd) :  $adqc = $adqd) ↦ (((mul) ($adqc)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))) = ((mul) ($adqd)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))}(($adqc :  FreeGroup) ↦ (Refl(FreeGroup,((mul) ($adqc)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))) ((&lt;function1&gt;) (n) : (((mul) (w)) (((mul) (y)) ((&lt;function1&gt;) (n))) = ((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (y)))) : (((mul) (w)) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))) = ((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (((mul) (y)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))) : ((l) (((mul) (w)) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w))))))))) = (l) (((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (((mul) (y)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w))))))))))) : ((l) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul...

scala&gt; val step = cbnd(lbnBounded) 

step: PosWit = ((ind{($blsxk :  Q.Typ) ↦ (($blsxl :  Q.Typ) ↦ ($blsxk = $blsxl))((l) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (z)))))))((l) (((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (((mul) (y)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w))))))))))}{($taxo :  Q.Typ) ↦ (($taxp :  Q.Typ) ↦ ((_ : ($taxo = $taxp) :  $taxo = $taxp) ↦ ((Pos(((l) (t) + ((&lt;function1&gt;) (n) * (l) (z)) + (l) (y) + (l) ((inv) (s)) + ((prod) (-1)) ($taxo) + (l) (z) + ((l) (y) * (&lt;function1&gt;) (n))))) → (Pos((((prod) (-1)) ($taxp) + (l) (t) + ((&lt;function1&gt;) (n) * (l) (z)) + (l) (y) + (l) ((inv) (s)) + (l) (z) + ((l) (y) * (&lt;function1&gt;) (n))))))))}(($taxo :  Q.Typ) ↦ (($adhgo : (Pos((((prod) (-1)) ($taxo) + (l) (t) + ((l) (z) * (&lt;function1&gt;) (n)) + (l) (y) + (l) ((inv) (s)) + (l) (z) + ((l) (y) * (&lt;function1&gt;) (n))))) :  Pos((((prod) (-1)) ($taxo) + (l) (t) + ((l) (z) * (&lt;function1&gt;) (n)) + (l) (y) + (l) ((inv) (s)) + (l) (z) + ((l) (y) * (&lt;function1&gt;) (n))))) ↦ ($adhgo : (Pos((((prod) (-1)) ($taxo) + (l) (t) + ((&lt;function1&gt;) (n) * (l) (z)) + (l) (y) + (l) ((inv) (s)) + (l) (z) + ((l) (y) * (&lt;function1&gt;) (n))))))))) (((ind{($stpx :  Q.Typ) ↦ (($stpy :  Q.Typ) ↦ ($stpx = $stpy))((l) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (z)))))))((l) (((mul) (w)) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w))))))))))}{($hiur :  Q.Typ) ↦ (($hius :  Q.Typ) ↦ ((_ : ($hiur = $hius) :  $hiur = $hius) ↦ (($hius = (l) (((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (((mul) (y)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))) → ($hiur = (l) (((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (((mul) (y)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))))))}(($hiur :  Q.Typ) ↦ (($hjjh : ($hiur = (l) (((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (((mul) (y)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))) :  $hiur = (l) (((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (((mul) (y)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))) ↦ ($hjjh : ($hiur = (l) (((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (((mul) (y)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))))))) (((conjugacy-invariance) (w)) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (z)))))) : ((l) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (z)))))) = (l) (((mul) (w)) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))))) ((ind{($stqa :  FreeGroup) ↦ (($stqb :  FreeGroup) ↦ ($stqa = $stqb))(((mul) (w)) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))(((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (((mul) (y)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))}{($dtmg :  FreeGroup) ↦ (($dtmh :  FreeGroup) ↦ ((_ : ($dtmg = $dtmh) :  $dtmg = $dtmh) ↦ ((l) ($dtmg) = (l) ($dtmh))))}(($dtmg :  FreeGroup) ↦ (Refl(Q.Typ,(l) ($dtmg))))) ((ind{($dpez :  FreeGroup) ↦ (($dpfa :  FreeGroup) ↦ ($dpez = $dpfa))(((mul) (w)) (((mul) (y)) ((&lt;function1&gt;) (n))))(((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (y)))}{($adqc :  FreeGroup) ↦ (($adqd :  FreeGroup) ↦ ((_ : ($adqc = $adqd) :  $adqc = $adqd) ↦ (((mul) ($adqc)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))) = ((mul) ($adqd)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))}(($adqc :  FreeGroup) ↦ (Refl(FreeGroup,((mul) ($adqc)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))) ((&lt;function1&gt;) (n) : (((mul) (w)) (((mul) (y)) ((&lt;function1&gt;) (n))) = ((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (y)))) : (((mul) (w)) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))) = ((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (((mul) (y)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w)))))))))) : ((l) (((mul) (w)) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w))))))))) = (l) (((mul) ((&lt;function1&gt;) (n))) (((mul) (w)) (((mul) (y)) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) (((mul) (z)) ((inv) (w))))))))))) : ((l) (((mul) (y)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mu...

scala&gt; assert(step.typ == lemma(succ(n)))
</code></pre>
<p>Finally, the lemma is proved by induction.</p>
<pre><code class="language-scala">scala&gt; val lemmaProof = Induc(lemma, baseCase, n :~&gt; (hyp :-&gt; step)) 

lemmaProof: Induc[PosWit with Subs[PosWit]] = &lt;function1&gt;

scala&gt; assert(lemmaProof.typ == (n ~&gt;: (lemma(n))) )
</code></pre>
<h2>Rest of the proof of the theorem</h2>
<p>Some work remains, essentially to use symbolic algebra for equations such as $x^{2n} = x^nx^n$
and to put together equations and inequalities. We introduce terms witnessing the hypotheses $x=swys^{-1}$ and $x=tzw^{-1}t^{-1}$</p>
<pre><code class="language-scala">scala&gt; val x = &quot;x&quot; :: FreeGroup 

x: RepTerm[Word] with Subs[RepTerm[Word]] = x

scala&gt; val g = &quot;g&quot; :: FreeGroup 

g: RepTerm[Word] with Subs[RepTerm[Word]] = g

scala&gt; val pown = g :-&gt; FreeGroup.power(g)(n) 

pown: Func[RepTerm[Word] with Subs[RepTerm[Word]], RepTerm[Word]] = (g :  FreeGroup) ↦ ((&lt;function1&gt;) (n))

scala&gt;  

scala&gt; val c1 = &quot;x ~ wy&quot; :: (x =:= (s |+| w |+| y |+| s.inverse)) 

c1: Equality[RepTerm[Word] with Subs[RepTerm[Word]]] with Subs[Equality[RepTerm[Word] with Subs[RepTerm[Word]]]] = x ~ wy : (x = ((mul) (s)) (((mul) (w)) (((mul) (y)) ((inv) (s)))))

scala&gt; val c2 = &quot;x ~ zw^{-1}&quot; :: (x =:= (t |+| z |+| w.inverse |+| t.inverse)) 

c2: Equality[RepTerm[Word] with Subs[RepTerm[Word]]] with Subs[Equality[RepTerm[Word] with Subs[RepTerm[Word]]]] = x ~ zw^{-1} : (x = ((mul) (t)) (((mul) (z)) (((mul) ((inv) (w))) ((inv) (t)))))
</code></pre>
<p>We deduce using a theorem (in our code) about powers of conjugates that $x^n = s(wy)^ns^{-1} = t(zw^{-1})^nt^{-1}$.</p>
<pre><code class="language-scala">scala&gt; val xnConjwyn = (pown *: c1) &amp;&amp; ConjPower.pf(s)(wy)(n) 

xnConjwyn: Equality[RepTerm[Word] with Subs[RepTerm[Word]]] = ((ind{($bqdte :  FreeGroup) ↦ (($bqdtf :  FreeGroup) ↦ ($bqdte = $bqdtf))((&lt;function1&gt;) (n))((&lt;function1&gt;) (n))}{($boyer :  FreeGroup) ↦ (($boyes :  FreeGroup) ↦ ((_ : ($boyer = $boyes) :  $boyer = $boyes) ↦ (($boyes = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (s)))) → ($boyer = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (s)))))))}(($boyer :  FreeGroup) ↦ (($boyth : ($boyer = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (s)))) :  $boyer = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (s)))) ↦ ($boyth : ($boyer = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (s)))))))) ((ind{($bpbme :  FreeGroup) ↦ (($bpbmf :  FreeGroup) ↦ ($bpbme = $bpbmf))(x)(((mul) (s)) (((mul) (w)) (((mul) (y)) ((inv) (s)))))}{($bngwp :  FreeGroup) ↦ (($bngwq :  FreeGroup) ↦ ((_ : ($bngwp = $bngwq) :  $bngwp = $bngwq) ↦ ((&lt;function1&gt;) (n) = (&lt;function1&gt;) (n))))}(($bngwp :  FreeGroup) ↦ (Refl(FreeGroup,(&lt;function1&gt;) (n))))) (x ~ wy : (x = ((mul) (s)) (((mul) (w)) (((mul) (y)) ((inv) (s)))))) : ((&lt;function1&gt;) (n) = (&lt;function1&gt;) (n)))) ((&lt;function1&gt;) (n) : ((&lt;function1&gt;) (n) = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (s))))) : ((&lt;function1&gt;) (n) = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (s))))

scala&gt; val xnConjzwbarn= (pown *: c2) &amp;&amp; ConjPower.pf(t)(zwbar)(n) 

xnConjzwbarn: Equality[RepTerm[Word] with Subs[RepTerm[Word]]] = ((ind{($brzwc :  FreeGroup) ↦ (($brzwd :  FreeGroup) ↦ ($brzwc = $brzwd))((&lt;function1&gt;) (n))((&lt;function1&gt;) (n))}{($bqtcv :  FreeGroup) ↦ (($bqtcw :  FreeGroup) ↦ ((_ : ($bqtcv = $bqtcw) :  $bqtcv = $bqtcw) ↦ (($bqtcw = ((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t)))) → ($bqtcv = ((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t)))))))}(($bqtcv :  FreeGroup) ↦ (($bqtrl : ($bqtcv = ((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t)))) :  $bqtcv = ((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t)))) ↦ ($bqtrl : ($bqtcv = ((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t)))))))) ((ind{($bqwki :  FreeGroup) ↦ (($bqwkj :  FreeGroup) ↦ ($bqwki = $bqwkj))(x)(((mul) (t)) (((mul) (z)) (((mul) ((inv) (w))) ((inv) (t)))))}{($bqdth :  FreeGroup) ↦ (($bqdti :  FreeGroup) ↦ ((_ : ($bqdth = $bqdti) :  $bqdth = $bqdti) ↦ ((&lt;function1&gt;) (n) = (&lt;function1&gt;) (n))))}(($bqdth :  FreeGroup) ↦ (Refl(FreeGroup,(&lt;function1&gt;) (n))))) (x ~ zw^{-1} : (x = ((mul) (t)) (((mul) (z)) (((mul) ((inv) (w))) ((inv) (t)))))) : ((&lt;function1&gt;) (n) = (&lt;function1&gt;) (n)))) ((&lt;function1&gt;) (n) : ((&lt;function1&gt;) (n) = ((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))) : ((&lt;function1&gt;) (n) = ((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))

scala&gt; assert(xnConjwyn.typ == (pown(x) =:= (s |+| pown(wy)  |+| s.inverse  ) ) ) 


scala&gt; assert(xnConjzwbarn.typ == (pown(x) =:= (t |+| pown(zwbar)  |+| t.inverse  ) ) )
</code></pre>
<p>We use the above equations to show that $x^nx^n = s(wy)^ns^{-1}t(zw^{-1})^nt^{-1}$.</p>
<pre><code class="language-scala">scala&gt; val t1 = s |+| pown(wy)  |+| s.inverse 

t1: LocalTerm = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (s)))

scala&gt; val t2 = t |+| pown(zwbar)  |+| t.inverse 

t2: LocalTerm = ((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t)))

scala&gt; val xnxnExpr = (FreeGroup.rm(pown(x)) *: xnConjwyn) &amp;&amp; (FreeGroup.lm(t1) *: xnConjzwbarn) 

xnxnExpr: Equality[LocalTerm with Subs[LocalTerm]] = ((ind{($cazcf :  FreeGroup) ↦ (($cazcg :  FreeGroup) ↦ ($cazcf = $cazcg))(((mul) ((&lt;function1&gt;) (n))) ((&lt;function1&gt;) (n)))(((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) ((&lt;function1&gt;) (n)))))}{($bwaao :  FreeGroup) ↦ (($bwaap :  FreeGroup) ↦ ((_ : ($bwaao = $bwaap) :  $bwaao = $bwaap) ↦ (($bwaap = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))))) → ($bwaao = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))))))))}(($bwaao :  FreeGroup) ↦ (($bwape : ($bwaao = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))))) :  $bwaao = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))))) ↦ ($bwape : ($bwaao = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))))))))) ((ind{($bwgrr :  FreeGroup) ↦ (($bwgrs :  FreeGroup) ↦ ($bwgrr = $bwgrs))((&lt;function1&gt;) (n))(((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (s))))}{($bsabp :  FreeGroup) ↦ (($bsabq :  FreeGroup) ↦ ((_ : ($bsabp = $bsabq) :  $bsabp = $bsabq) ↦ (((mul) ($bsabp)) ((&lt;function1&gt;) (n)) = ((mul) ($bsabq)) ((&lt;function1&gt;) (n)))))}(($bsabp :  FreeGroup) ↦ (Refl(FreeGroup,((mul) ($bsabp)) ((&lt;function1&gt;) (n)))))) (((ind{($bqdte :  FreeGroup) ↦ (($bqdtf :  FreeGroup) ↦ ($bqdte = $bqdtf))((&lt;function1&gt;) (n))((&lt;function1&gt;) (n))}{($boyer :  FreeGroup) ↦ (($boyes :  FreeGroup) ↦ ((_ : ($boyer = $boyes) :  $boyer = $boyes) ↦ (($boyes = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (s)))) → ($boyer = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (s)))))))}(($boyer :  FreeGroup) ↦ (($boyth : ($boyer = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (s)))) :  $boyer = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (s)))) ↦ ($boyth : ($boyer = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (s)))))))) ((ind{($bpbme :  FreeGroup) ↦ (($bpbmf :  FreeGroup) ↦ ($bpbme = $bpbmf))(x)(((mul) (s)) (((mul) (w)) (((mul) (y)) ((inv) (s)))))}{($bngwp :  FreeGroup) ↦ (($bngwq :  FreeGroup) ↦ ((_ : ($bngwp = $bngwq) :  $bngwp = $bngwq) ↦ ((&lt;function1&gt;) (n) = (&lt;function1&gt;) (n))))}(($bngwp :  FreeGroup) ↦ (Refl(FreeGroup,(&lt;function1&gt;) (n))))) (x ~ wy : (x = ((mul) (s)) (((mul) (w)) (((mul) (y)) ((inv) (s)))))) : ((&lt;function1&gt;) (n) = (&lt;function1&gt;) (n)))) ((&lt;function1&gt;) (n) : ((&lt;function1&gt;) (n) = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (s))))) : ((&lt;function1&gt;) (n) = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (s))))) : (((mul) ((&lt;function1&gt;) (n))) ((&lt;function1&gt;) (n)) = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) ((&lt;function1&gt;) (n))))))) ((ind{($cazci :  FreeGroup) ↦ (($cazcj :  FreeGroup) ↦ ($cazci = $cazcj))((&lt;function1&gt;) (n))(((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))}{($btoxs :  FreeGroup) ↦ (($btoxt :  FreeGroup) ↦ ((_ : ($btoxs = $btoxt) :  $btoxs = $btoxt) ↦ (((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) ($btoxs))) = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) ($btoxt))))))}(($btoxs :  FreeGroup) ↦ (Refl(FreeGroup,((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) ($btoxs))))))) (((ind{($brzwc :  FreeGroup) ↦ (($brzwd :  FreeGroup) ↦ ($brzwc = $brzwd))((&lt;function1&gt;) (n))((&lt;function1&gt;) (n))}{($bqtcv :  FreeGroup) ↦ (($bqtcw :  FreeGroup) ↦ ((_ : ($bqtcv = $bqtcw) :  $bqtcv = $bqtcw) ↦ (($bqtcw = ((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t)))) → ($bqtcv = ((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t)))))))}(($bqtcv :  FreeGroup) ↦ (($bqtrl : ($bqtcv = ((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t)))) :  $bqtcv = ((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t)))) ↦ ($bqtrl : ($bqtcv = ((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t)))))))) ((ind{($bqwki :  FreeGroup) ↦ (($bqwkj :  FreeGroup) ↦ ($bqwki = $bqwkj))(x)(((mul) (t)) (((mul) (z)) (((mul) ((inv) (w))) ((inv) (t)))))}{($bqdth :  FreeGroup) ↦ (($bqdti :  FreeGroup) ↦ ((_ : ($bqdth = $bqdti) :  $bqdth = $bqdti) ↦ ((&lt;function1&gt;) (n) = (&lt;function1&gt;) (n))))}(($bqdth :  FreeGroup) ↦ (Refl(FreeGroup,(&lt;function1&gt;) (n))))) (x ~ zw^{-1} : (x = ((mul) (t)) (((mul) (z)) (((mul) ((inv) (w))) ((inv) (t)))))) : ((&lt;function1&gt;) (n) = (&lt;function1&gt;) (n)))) ((&lt;function1&gt;) (n) : ((&lt;function1&gt;) (n) = ((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))) : ((&lt;function1&gt;) (n) = ((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))) : (((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) ((&lt;function1&gt;) (n)))) = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t)))))))) : (((mul) ((&lt;function1&gt;) (n))) ((&lt;function1&gt;) (n)) = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t)))))))

scala&gt; assert(xnxnExpr.typ == ((pown(x) |+| pown(x)) =:= (t1 |+| t2 )   ))
</code></pre>
<p>Using $x^nx^n = x^{2n}$, we get the formula $x^{2n} = s(wy)^ns^{-1}t(zw^{-1})^nt^{-1}$.</p>
<pre><code class="language-scala">scala&gt; val x2nExpr =PowerDistributive.pf(x)(n)(n).sym &amp;&amp; xnxnExpr 

x2nExpr: Equality[LocalTerm with Subs[LocalTerm] with Subs[LocalTerm with Subs[LocalTerm]]] = ((ind{($cdojo :  FreeGroup) ↦ (($cdojp :  FreeGroup) ↦ ($cdojo = $cdojp))((&lt;function1&gt;) (((prod) (2)) (n)))(((mul) ((&lt;function1&gt;) (n))) ((&lt;function1&gt;) (n)))}{($cbogt :  FreeGroup) ↦ (($cbogu :  FreeGroup) ↦ ((_ : ($cbogt = $cbogu) :  $cbogt = $cbogu) ↦ (($cbogu = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))))) → ($cbogt = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))))))))}(($cbogt :  FreeGroup) ↦ (($cbovj : ($cbogt = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))))) :  $cbogt = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))))) ↦ ($cbovj : ($cbogt = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))))))))) ((ind{($cbscr :  FreeGroup) ↦ (($cbscs :  FreeGroup) ↦ ($cbscr = $cbscs))(((mul) ((&lt;function1&gt;) (n))) ((&lt;function1&gt;) (n)))((&lt;function1&gt;) (((prod) (2)) (n)))}{($cbckh :  FreeGroup) ↦ (($cbcki :  FreeGroup) ↦ ((_ : ($cbckh = $cbcki) :  $cbckh = $cbcki) ↦ ($cbcki = $cbckh)))}(($cbckh :  FreeGroup) ↦ (Refl(FreeGroup,$cbckh)))) ((&lt;function1&gt;) (n) : (((mul) ((&lt;function1&gt;) (n))) ((&lt;function1&gt;) (n)) = (&lt;function1&gt;) (((prod) (2)) (n)))) : ((&lt;function1&gt;) (((prod) (2)) (n)) = ((mul) ((&lt;function1&gt;) (n))) ((&lt;function1&gt;) (n))))) (((ind{($cazcf :  FreeGroup) ↦ (($cazcg :  FreeGroup) ↦ ($cazcf = $cazcg))(((mul) ((&lt;function1&gt;) (n))) ((&lt;function1&gt;) (n)))(((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) ((&lt;function1&gt;) (n)))))}{($bwaao :  FreeGroup) ↦ (($bwaap :  FreeGroup) ↦ ((_ : ($bwaao = $bwaap) :  $bwaao = $bwaap) ↦ (($bwaap = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))))) → ($bwaao = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))))))))}(($bwaao :  FreeGroup) ↦ (($bwape : ($bwaao = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))))) :  $bwaao = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))))) ↦ ($bwape : ($bwaao = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))))))))) ((ind{($bwgrr :  FreeGroup) ↦ (($bwgrs :  FreeGroup) ↦ ($bwgrr = $bwgrs))((&lt;function1&gt;) (n))(((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (s))))}{($bsabp :  FreeGroup) ↦ (($bsabq :  FreeGroup) ↦ ((_ : ($bsabp = $bsabq) :  $bsabp = $bsabq) ↦ (((mul) ($bsabp)) ((&lt;function1&gt;) (n)) = ((mul) ($bsabq)) ((&lt;function1&gt;) (n)))))}(($bsabp :  FreeGroup) ↦ (Refl(FreeGroup,((mul) ($bsabp)) ((&lt;function1&gt;) (n)))))) (((ind{($bqdte :  FreeGroup) ↦ (($bqdtf :  FreeGroup) ↦ ($bqdte = $bqdtf))((&lt;function1&gt;) (n))((&lt;function1&gt;) (n))}{($boyer :  FreeGroup) ↦ (($boyes :  FreeGroup) ↦ ((_ : ($boyer = $boyes) :  $boyer = $boyes) ↦ (($boyes = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (s)))) → ($boyer = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (s)))))))}(($boyer :  FreeGroup) ↦ (($boyth : ($boyer = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (s)))) :  $boyer = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (s)))) ↦ ($boyth : ($boyer = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (s)))))))) ((ind{($bpbme :  FreeGroup) ↦ (($bpbmf :  FreeGroup) ↦ ($bpbme = $bpbmf))(x)(((mul) (s)) (((mul) (w)) (((mul) (y)) ((inv) (s)))))}{($bngwp :  FreeGroup) ↦ (($bngwq :  FreeGroup) ↦ ((_ : ($bngwp = $bngwq) :  $bngwp = $bngwq) ↦ ((&lt;function1&gt;) (n) = (&lt;function1&gt;) (n))))}(($bngwp :  FreeGroup) ↦ (Refl(FreeGroup,(&lt;function1&gt;) (n))))) (x ~ wy : (x = ((mul) (s)) (((mul) (w)) (((mul) (y)) ((inv) (s)))))) : ((&lt;function1&gt;) (n) = (&lt;function1&gt;) (n)))) ((&lt;function1&gt;) (n) : ((&lt;function1&gt;) (n) = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (s))))) : ((&lt;function1&gt;) (n) = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (s))))) : (((mul) ((&lt;function1&gt;) (n))) ((&lt;function1&gt;) (n)) = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) ((&lt;function1&gt;) (n))))))) ((ind{($cazci :  FreeGroup) ↦ (($cazcj :  FreeGroup) ↦ ($cazci = $cazcj))((&lt;function1&gt;) (n))(((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))}{($btoxs :  FreeGroup) ↦ (($btoxt :  FreeGroup) ↦ ((_ : ($btoxs = $btoxt) :  $btoxs = $btoxt) ↦ (((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) ($btoxs))) = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) ($btoxt))))))}(($btoxs :  FreeGroup) ↦ (Refl(FreeGroup,((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) ($btoxs))))))) (((ind{($brzwc :  FreeGroup) ↦ (($brzwd :  FreeGroup) ↦ ($brzwc = $brzwd))((&lt;function1&gt;) (n))((&lt;function1&gt;) (n))}{($...

scala&gt; assert(x2nExpr.typ == (FreeGroup.power(x)(NatRing.prod(n)(nat(2))) =:= (s |+| c(n) |+| t.inverse)))
</code></pre>
<p>We now bound the length of the right hand side $s(wy)^ns^{-1}t(zw^{-1})^nt^{-1}$.</p>
<pre><code class="language-scala">scala&gt; val thmBound = f(n) + l(s) + l(t.inverse) 

thmBound: LocalTerm = ((l) (s) + (l) (t) + ((l) (z) * (&lt;function1&gt;) (n)) + (l) ((inv) (t)) + (l) ((inv) (s)) + ((l) (y) * (&lt;function1&gt;) (n)))

scala&gt; val exprBound = lemmaProof(n) + triang(s)(c(n)) + triang(s |+| c(n))(t.inverse) 

exprBound: PosWitSum = PosWitSum(PosWitSum((&lt;function1&gt;) (n) : (Pos(((l) (t) + ((&lt;function1&gt;) (n) * (l) (z)) + ((prod) (-1)) ((l) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) ((&lt;function1&gt;) (n)))))) + (l) ((inv) (s)) + ((l) (y) * (&lt;function1&gt;) (n))))),((triangle-inequality) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) ((&lt;function1&gt;) (n))))) : (Pos((((prod) (-1)) ((l) (((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) ((&lt;function1&gt;) (n))))))) + (l) (s) + (l) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) ((&lt;function1&gt;) (n))))))))),((triangle-inequality) (((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) ((&lt;function1&gt;) (n))))))) ((inv) (t)) : (Pos((((prod) (-1)) ((l) (((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t)))))))) + (l) (((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) ((&lt;function1&gt;) (n)))))) + (l) ((inv) (t))))))

scala&gt; assert(exprBound.typ == leq(l(s |+| c(n) |+| t.inverse ))(thmBound))
</code></pre>
<p>We easily deduce the bound on $l(x^{2n})$ to complete the proof.</p>
<pre><code class="language-scala">scala&gt; val thmProof = x2nExpr.sym.lift (g :-&gt; leq(l(g))(thmBound))(exprBound) 

thmProof: PosWit = ((ind{($dxxgd :  FreeGroup) ↦ (($dxxge :  FreeGroup) ↦ ($dxxgd = $dxxge))(((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t)))))))((&lt;function1&gt;) (((prod) (2)) (n)))}{($chfpg :  FreeGroup) ↦ (($chfph :  FreeGroup) ↦ ((_ : ($chfpg = $chfph) :  $chfpg = $chfph) ↦ ((Pos(((l) (s) + ((prod) (-1)) ((l) ($chfpg)) + (l) (t) + ((l) (z) * (&lt;function1&gt;) (n)) + (l) ((inv) (t)) + (l) ((inv) (s)) + ((l) (y) * (&lt;function1&gt;) (n))))) → (Pos(((l) (s) + (l) (t) + ((l) (z) * (&lt;function1&gt;) (n)) + (l) ((inv) (t)) + (l) ((inv) (s)) + ((l) (y) * (&lt;function1&gt;) (n)) + ((prod) (-1)) ((l) ($chfph))))))))}(($chfpg :  FreeGroup) ↦ (($cucyc : (Pos(((l) (s) + (l) (t) + ((&lt;function1&gt;) (n) * (l) (z)) + (l) ((inv) (t)) + (l) ((inv) (s)) + ((l) (y) * (&lt;function1&gt;) (n)) + ((prod) (-1)) ((l) ($chfpg))))) :  Pos(((l) (s) + (l) (t) + ((&lt;function1&gt;) (n) * (l) (z)) + (l) ((inv) (t)) + (l) ((inv) (s)) + ((l) (y) * (&lt;function1&gt;) (n)) + ((prod) (-1)) ((l) ($chfpg))))) ↦ ($cucyc : (Pos(((l) (s) + (l) (t) + ((l) (z) * (&lt;function1&gt;) (n)) + (l) ((inv) (t)) + (l) ((inv) (s)) + ((l) (y) * (&lt;function1&gt;) (n)) + ((prod) (-1)) ((l) ($chfpg))))))))) ((ind{($dokln :  FreeGroup) ↦ (($doklo :  FreeGroup) ↦ ($dokln = $doklo))((&lt;function1&gt;) (((prod) (2)) (n)))(((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t)))))))}{($cdwje :  FreeGroup) ↦ (($cdwjf :  FreeGroup) ↦ ((_ : ($cdwje = $cdwjf) :  $cdwje = $cdwjf) ↦ ($cdwjf = $cdwje)))}(($cdwje :  FreeGroup) ↦ (Refl(FreeGroup,$cdwje)))) (((ind{($cdojo :  FreeGroup) ↦ (($cdojp :  FreeGroup) ↦ ($cdojo = $cdojp))((&lt;function1&gt;) (((prod) (2)) (n)))(((mul) ((&lt;function1&gt;) (n))) ((&lt;function1&gt;) (n)))}{($cbogt :  FreeGroup) ↦ (($cbogu :  FreeGroup) ↦ ((_ : ($cbogt = $cbogu) :  $cbogt = $cbogu) ↦ (($cbogu = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))))) → ($cbogt = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))))))))}(($cbogt :  FreeGroup) ↦ (($cbovj : ($cbogt = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))))) :  $cbogt = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))))) ↦ ($cbovj : ($cbogt = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))))))))) ((ind{($cbscr :  FreeGroup) ↦ (($cbscs :  FreeGroup) ↦ ($cbscr = $cbscs))(((mul) ((&lt;function1&gt;) (n))) ((&lt;function1&gt;) (n)))((&lt;function1&gt;) (((prod) (2)) (n)))}{($cbckh :  FreeGroup) ↦ (($cbcki :  FreeGroup) ↦ ((_ : ($cbckh = $cbcki) :  $cbckh = $cbcki) ↦ ($cbcki = $cbckh)))}(($cbckh :  FreeGroup) ↦ (Refl(FreeGroup,$cbckh)))) ((&lt;function1&gt;) (n) : (((mul) ((&lt;function1&gt;) (n))) ((&lt;function1&gt;) (n)) = (&lt;function1&gt;) (((prod) (2)) (n)))) : ((&lt;function1&gt;) (((prod) (2)) (n)) = ((mul) ((&lt;function1&gt;) (n))) ((&lt;function1&gt;) (n))))) (((ind{($cazcf :  FreeGroup) ↦ (($cazcg :  FreeGroup) ↦ ($cazcf = $cazcg))(((mul) ((&lt;function1&gt;) (n))) ((&lt;function1&gt;) (n)))(((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) ((&lt;function1&gt;) (n)))))}{($bwaao :  FreeGroup) ↦ (($bwaap :  FreeGroup) ↦ ((_ : ($bwaao = $bwaap) :  $bwaao = $bwaap) ↦ (($bwaap = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))))) → ($bwaao = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))))))))}(($bwaao :  FreeGroup) ↦ (($bwape : ($bwaao = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))))) :  $bwaao = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))))) ↦ ($bwape : ($bwaao = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) (((mul) ((inv) (s))) (((mul) (t)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (t))))))))))) ((ind{($bwgrr :  FreeGroup) ↦ (($bwgrs :  FreeGroup) ↦ ($bwgrr = $bwgrs))((&lt;function1&gt;) (n))(((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (s))))}{($bsabp :  FreeGroup) ↦ (($bsabq :  FreeGroup) ↦ ((_ : ($bsabp = $bsabq) :  $bsabp = $bsabq) ↦ (((mul) ($bsabp)) ((&lt;function1&gt;) (n)) = ((mul) ($bsabq)) ((&lt;function1&gt;) (n)))))}(($bsabp :  FreeGroup) ↦ (Refl(FreeGroup,((mul) ($bsabp)) ((&lt;function1&gt;) (n)))))) (((ind{($bqdte :  FreeGroup) ↦ (($bqdtf :  FreeGroup) ↦ ($bqdte = $bqdtf))((&lt;function1&gt;) (n))((&lt;function1&gt;) (n))}{($boyer :  FreeGroup) ↦ (($boyes :  FreeGroup) ↦ ((_ : ($boyer = $boyes) :  $boyer = $boyes) ↦ (($boyes = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (s)))) → ($boyer = ((mul) (s)) (((mul) ((&lt;function1&gt;) (n))) ((inv) (s)))))))}(($boyer :  FreeGroup) ↦ (($boyth : ($boyer = ((mul) (s)) (((mul) (...

scala&gt; val x2n = FreeGroup.power(x)(NatRing.prod(n)(nat(2))) 

x2n: RepTerm[Word] = (&lt;function1&gt;) (((prod) (2)) (n))

scala&gt; assert(thmProof.typ == leq(l(x2n))(thmBound )) 


scala&gt;
</code></pre>
<h3>Git Log</h3>
<pre><code>commit ac0b3d1fc041bd9cfae3addbc3b35a6d7817ecce
Author: Siddhartha Gadgil &lt;siddhartha.gadgil@gmail.com&gt;
Date:   Thu May 31 21:08:15 2018 +0530

    latex in editor, including PiDefn
</code></pre>
<ul>
<li><strong>Branch</strong> : master</li>
</ul>


</div>
</div>

<div class="container-fluid">
  <p>&nbsp;</p>
  <p>&nbsp;</p>
  <p>&nbsp;</p>
  <div class="footer navbar-fixed-bottom bg-primary">
    <h4>
    &nbsp;Developed by:
    &nbsp;<a href="http://math.iisc.ac.in/~gadgil" target="_blank">&nbsp; Siddhartha Gadgil</a>

  </h4>

  </div>


</div>
<script type="text/javascript" src="../js/jquery-2.1.4.min.js"></script>
<script type="text/javascript" src="../js/bootstrap.min.js"></script>
<script type="text/javascript" src="../js/provingground.js"></script>
<script>
  provingground.main()
</script>

</body>
</html>
